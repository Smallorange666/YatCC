## 公共代码

在本实验的 `common` 文件夹下存在如下几个代码文件：

```bash
common/
├── Asg2Json.cpp
├── Asg2Json.hpp
├── Obj.cpp
├── Obj.hpp
├── Typing.cpp
├── Typing.hpp
├── asg.cpp
└── asg.hpp
```

这几个文件是无论使用 ANTLR 还是使用 Bison 进行实验二的实现都会用到的代码，接下来，我们依次介绍。

注：虽然接下来介绍的实际上都是“结构体”，但是为了表述方便，我们都称呼为“类”。

## Obj

`Obj` 类及相关的结构是一个为内存管理和类型系统设计的框架。这个框架的设计目的是为了在 ASG 构建和操作过程中，提供一个灵活、高效的内存管理和类型标注体系。

### Obj 类

`Obj` 类是所有对象的基类，它定义了一套通用的接口和一些基本的属性。这个设计允许在 ASG 中不同种类的节点之间进行通用操作，同时提供了标准的内存管理和类型识别机制。

主要特性和成员

- `any`：这是一个 `void*` 指针，可以用来存储任意类型的数据。这提供了一种灵活的方式，让不同的 ASG 节点可以附加额外的信息或状态。
- `__next__`：这是一个指向下一个`Obj`对象的指针。这样`Obj`对象形成一个链表结构，方便管理所有创建的对象，特别是垃圾回收机制。

### Obj::Mgr 类

`Obj::Mgr` 类是一个对象管理器，负责管理所有通过它创建的 `Obj` 派生对象的生命周期。它使用标记-清除算法来实现垃圾回收，防止内存泄漏。

垃圾回收机制涉及以下两个成员：

- `gc()`：执行垃圾回收。这个方法首先标记所有从根对象可达的对象，然后清扫那些未被标记的对象。
- `__mark__()`：这是一个虚函数，用于标记过程中递归标记所有可达的对象。

### Obj::Walked 类

`Obj::Walked` 是一个辅助类，用于检测和防止在对象图遍历过程中发生的循环引用问题。通过在遍历开始时构造`Obj::Walked` 实例，并在遍历结束时自动析构，它可以暂时修改对象的状态来标记已访问的对象，从而避免无限循环。例如在对 ASG 进行深度优先搜索（DFS）等操作时，`Obj::Walked` 可以确保每个节点只被访问一次，即使图中存在循环引用。

---

总的来说，在 ASG 构建和操作过程中，所有的节点都继承自 `Obj` 类，确保了类型的统一和内存的可管理性。`Obj::Mgr`实例作为对象的容器和管理者，控制着所有对象的生命周期，并提供垃圾回收机制。在遍历或分析`ASG`时，`Obj::Walked` 用于保护遍历算法不会因循环引用而陷入死循环。

## asg

`asg` 命名空间中定义了一系列类和函数，它们构成了将 AST 转换为抽象语法图 ASG 以及将 ASG 转为 JSON 的基础。ASG 是源代码抽象语法树 AST 的进一步抽象，旨在提供更丰富的语义表示，以便进行类型检查、优化等编译阶段的处理。以下是这部分代码的详细介绍：

### 核心类

1. `TranslationUnit` 类:

   - 代表整个程序或一个编译单元，是 ASG 的根节点。
   - 包含多个 `Decl` 类型的成员，代表在全局范围内声明的变量和函数。

2. `Decl` 类:

   - 是声明的基类，声明包括变量声明和函数声明等。
   - 具体的声明类由`Decl`类派生而来，例如 `VarDecl` 和 `FunctionDecl`等。

3. `Expr` 类:

   - 是表达式的基类，表达式包括字面量、二元运算、函数调用等。
   - 具体的表达式类由`Expr`类派生而来，例如 `IntegerLiteral`、`BinaryExpr` 和 `CallExpr`等。

4. `Stmt` 类:

   - 是语句的基类，语句包括表达式语句和复合语句等。
   - 具体的语句类由`Stmt`类派生而来，例如 `ExprStmt` 和 `CompoundStmt`等。

5. `Type` 类和 `TypeExpr` 类:

   - 这两者都用于表示节点的类型信息，包括基本类型和复合类型。
   - `TypeExpr` 类用于更复杂的类型表达，如数组和函数类型。

### 类之间的关系

- 从属关系：`TranslationUnit` 作为 ASG 的根节点，包含一系列的 `Decl` 实例，如 `VarDecl` 和 `FunctionDecl`，这些`Decl`实例代表全局声明的变量和函数。`Decl`实例中可能会包含对表达式的引用，例如函数返回类型或者变量初始化表达式，从而关联到 `Expr` 类及其派生类。
- 包含关系：`FunctionDecl` 类会包含 `Stmt` 类的实例，特别是复合语句 `CompoundStmt`以表示函数体。`CompoundStmt` 再包含更多的 `Stmt` 实例，形成一个语句树，这些语句可能是表达式语句 `ExprStmt`，或者是其他复合语句，形成层次结构。
- 引用关系：表达式类（`Expr` 类及其派生类）可能会（通过 `DeclRefExpr` 类）引用声明类，表示变量的使用或函数的调用。同时，表达式之间也会形成树状结构，如 `BinaryExpr` 的左右子表达式。

## Typing

`Typing` 类及其相关函数用来在 ASG 中进行类型推导和检查。`Typing` 类通过遍历 ASG 节点并分析其语义，填充或确认节点的类型信息，以便于后续的代码生成或其他分析阶段使用。接下来是对 `Typing` 类的详细介绍。

### 主要职责

1. **类型推导**：对 ASG 中的表达式和变量进行类型推导，确定它们的具体类型。
2. **类型检查**：确认代码中的类型使用是否正确，例如赋值操作的左右两侧类型是否兼容。
3. **类型转换**：根据需要插入隐式或显式的类型转换，保证操作的类型安全。

### 核心成员和方法

核心成员：

- `Obj::Mgr& mMgr`：对象管理器的引用，用于在类型推导过程中创建新的类型或表达式对象。
- `Type::Cache mTypeCache`：类型缓存，用于存储和复用类型实例，避免重复创建相同的类型对象。

核心方法

- `operator()(TranslationUnit* tu)`：对整个翻译单元进行类型推导。这是类型推导过程的入口点。
- `operator()(Expr* obj)`：对表达式进行类型推导。这个方法会根据表达式的种类调用更具体的处理函数。
- `operator()(Stmt* obj)`：对语句进行类型处理，确保语句中使用的表达式类型正确。
- `operator()(Decl* obj)`：对声明进行类型推导和检查，包括变量声明和函数声明。
- `ensure_rvalue(Expr* exp)`：确保表达式为右值，如果需要，进行左值到右值的转换。
- `promote_integer(Expr* exp, Type::Spec to = Type::Spec::kInt)`：进行整数提升，将小于 `int` 类型的整数类型提升为 `int` 或更大的整数类型。
- `assignment_cast(Expr* lft, Expr* rht)`：对赋值操作的右侧进行类型转换，确保与左侧类型兼容。

### 类型推导

在处理表达式时，`Typing` 类会根据表达式的类型进行分派，调用对应的处理函数。例如，对于整数字面量 `IntegerLiteral`，它会确定字面量的类型，判断是用 `int` 表示就够了，还是需要如 `long long`这样更大的类型。

```cpp
Expr* Typing::operator()(IntegerLiteral* obj) {
  // 确定字面量类型
  Type::Spec spec;
  if (obj->val <= INT32_MAX) {
    spec = Type::Spec::kInt;
  } else {
    spec = Type::Spec::kLongLong;
  }

  obj->type = mTypeCache(spec, Type::Qual{.const_ = true}, nullptr);
  obj->cate = Expr::Cate::kRValue;
  return obj;
}

```

### 类型检查与转换

对于赋值操作，Typing 会检查左右两侧的类型是否兼容，并在需要时插入隐式类型转换：

```cpp
Expr* Typing::assignment_cast(Expr* lft, Expr* rht) {
  // 检查类型兼容性，并进行必要的类型转换
  if (lft->type->spec != rht->type->spec) {
    auto cst = make<ImplicitCastExpr>();
    cst->kind = cst->kIntegralCast;
    cst->type = lft->type;
    cst->sub = rht;
    rht = cst;
  }
  return rht;
}

```

---

这些方法使得 `Typing` 类可以灵活地处理各种类型相关的语义规则，包括基本的类型推导、类型兼容性检查和必要的类型转换。通过将这些功能集中在 `Typing` 类中，代码的其余部分可以在不直接处理复杂类型规则的情况下，进行语义分析和代码生成。

## Asg2Json

`Asg2Json.cpp` 和 `Asg2Json.hpp` 定义了一个 `Asg2Json` 类，其作用是是将抽象语法图 ASG 转换为 JSON 格式的表示。这样的转换使得 ASG 的结构可以以文本形式展示，便于调试、可视化和进一步的处理。

### 主要职责

1. 进行转换：提供将 ASG 中不同节点（如声明、表达式、语句等）转换为 `json::Object` 对象的逻辑。
2. 输出格式化：生成的 JSON 格式化输出，使其易于阅读和理解。
3. 递归处理：能够递归处理 ASG 中的复杂结构，如函数内部的语句和表达式。

### operator() 重载

`Asg2Json` 类为 ASG 中的各种节点类型提供了 `operator()` 的重载，每个重载负责处理一种特定类型的节点，并将其转换为`json::Object`对象。

- `json::Object operator()(TranslationUnit* tu)`：用于处理整个翻译单元，作为转换的入口点。

- `json::Object operator()(Expr* obj)`：用于处理表达式。它会根据具体的表达式类型（通过动态类型识别）调用相应的处理函数。

- `json::Object operator()(Stmt* obj)`：用于处理语句，它会根据具体的语句类型调用相应的处理函数。

- `json::Object operator()(Decl* obj)` 用于处理声明。它会根据具体的声明类型（如变量声明或函数声明）调用相应的处理函数。

每种具体的表达式和语句类型（如 `IntegerLiteral`, `BinaryExpr`, `CompoundStmt` 等）都有对应的处理方法，这些方法生成代表该节点的`json::Object`对象，并递归地处理节点的子节点（如果有）。

## 类型的转换

- `std::string operator()(const Type* type)`：将类型信息转换为字符串表示，用于在 JSON 中表示变量或表达式的类型。
- `std::string operator()(TypeExpr* texp)`：处理复合类型表达式，如数组或函数类型。

## ASG 介绍

相比起 AST，在本实验中使用 ASG 更为恰当和合适。ASG 类似于 AST，只是其一种简化/变体，能够更方便的 JSON 化并输出。

### PT、AST 与 ASG

在学习了这么多编译原理的课程知识后，相信同学们已经了解了“语法解析树”和“抽象语法树”的概念。以下面这个简短的全局变量声明为例：

```cpp
int a[2] = {0, 1};
*b = a + 1;
```

我们来对比看看，在语法解析树、抽象语法树和抽象语义图中，这段代码是如何表示的。

- **语法解析树（Parse Tree，PT）**

  语法解析树包含语法解析过程中的所有非终结符号和终结符号，一个递归下降语法分析器的运行过程可以视为是对语法解析树的深度优先遍历。语法解析树通常是非常复杂和庞大的，因此一般并不会真的生成出来，例如上面的例子如果真的生成一个语法解析树，那他可能是这个样子：
  ![alt text](../images/bison/Parse_Tree.png)

  希望这张图能够让你感受到语法解析树的复杂和庞大。而实际上，上图其实已经简化了表达式相关语法规则（虚线部分），后面为我们会看到，因为运算符优先级的存在，每个表达式结点实际上都会产生出一个长长的分支链。

- **抽象语法树（Abstract Syntax Tree，AST）**

  抽象语法树通过去掉了只起到结构标识作用的结点、压缩树的层级等方式大大简化了语法解析树的结构。上面的例子对应的抽象语法树可能是：

  ![alt text](../images/bison/ast.png)

  很显然 AST 比语法解析树简单得多，ANTLR 和 Boost.Spirit 这类的语法解析器框架的输出结果往往都是这种形式。

- **抽象语义图（Abstract Semantic Graph，ASG）**

  单论名字的用法而言，大家并不是那么严格地区分“ASG”和“AST”，很多人把 ASG 的 IR 数据结构称为 AST，尽管这些数据结构的引用关系是在图上而并非树上。不过，与那些语法解析器框架相比，我们上面定义的 C++ 结构体们与之还是有很大差别的，这主要体现在语义结点的相互引用上：

  ![alt text](../images/bison/asg.png)

  相比于 AST ，我们在`declReference_1`中直接存储指向变量声明的那个语义结点指针而不是变量名，这将会给后面的分析和变换的代码编写带来极大的便利。

### 总结

其实，ASG 就是一种可以储存代码中的各个不同结构（比如，表达式，句子，声明）的一堆结构体。ASG 结构并不是必须的，只是为了在中间进行储存这些文法结构，从而之后进行 JSON 打印。这只是一种设计选择，当然也可以用其他的方式实现。
