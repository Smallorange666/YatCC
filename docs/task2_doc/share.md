# 公有代码与概念

在 `COMMON` 文件夹下存在如下几个代码文件，这几个文件是无论使用 `ANTLR` 还是使用 `BISON` 进行实验二的实现都会用到的代码，在这里对这几个文件进行统一的解读。

```bash
-- common
  |-- Asg2Json.cpp
  |-- Asg2Json.hpp
  |-- Obj.cpp
  |-- Obj.hpp
  |-- Typing.cpp
  |-- Typing.hpp
  |-- asg.cpp
  `-- asg.hpp
```


## Obj相关代码介绍

`Obj` 类及相关的结构是一个为内存管理和类型系统设计的框架。这个框架的设计目的是为了在抽象语法图（ASG）构建和操作过程中，提供一个灵活、高效的内存管理和类型标注体系。

### Obj类

`Obj` 类是所有对象的基类，它定义了一套通用的接口和一些基本的属性。这个设计允许在ASG中不同种类的节点之间进行通用操作，同时提供了标准的内存管理和类型识别机制。

主要特性和成员

- `any`: 这是一个 void* 指针，可以用来存储任意类型的数据。这提供了一种灵活的方式，让不同的ASG节点可以附加额外的信息或状态。
- `__next__`: 用于内部的内存管理，特别是垃圾回收机制。这是一个指向下一个对象的指针，形成一个链表结构，方便管理所有创建的对象。

### Obj::Mgr类

然后是 `Obj::Mgr` 类, `Obj::Mgr` 类是一个对象管理器，负责管理所有通过它创建的 `Obj` 派生对象的生命周期。它使用标记-清除算法来实现垃圾回收，防止内存泄漏。

垃圾回收机制

- `gc()`: 执行垃圾回收。这个方法首先标记所有从根对象可达的对象，然后清扫那些未被标记的对象。
- `__mark__`: 这是一个虚函数，用于标记过程中递归标记所有可达的对象。

### Obj::Walked类
`Obj::Walked` 是一个辅助类，用于检测和防止在对象图遍历过程中发生的循环引用问题。通过在遍历开始时构造`Obj::Walked` 实例，并在遍历结束时自动析构，它可以暂时修改对象的状态来标记已访问的对象，从而避免无限循环。例如在对`ASG`进行深度优先搜索（`DFS`）等操作时，`Obj::Walked` 可以确保每个节点只被访问一次，即使图中存在循环引用。

总的来说，在ASG构建和操作过程中，所有的节点都继承自 `Obj` 类，确保了类型的统一和内存的可管理性。`Obj::Mgr `实例作为对象的容器和管理者，控制着所有对象的生命周期，并提供垃圾回收机制。在遍历或分析`ASG`时，`Obj::Walked` 用于保护遍历算法不会因循环引用而陷入死循环。


## Asg 相关代码介绍

`asg` 命名空间定义了一系列类和函数，这些构成了将抽象语法树（`AST`）转换为抽象语法图（`ASG`）以及将`ASG`转为`json`的基础。`ASG` 是源代码抽象语法树（`AST`）的进一步抽象，旨在提供更丰富的语义表示，以便进行类型检查、优化等编译阶段的处理。以下是这部分代码的详细介绍：

### 核心类和结构体

1. `TranslationUnit`:
- 代表整个程序或一个编译单元，是`ASG`的根节点。
- 包含多个 `Decl` 类型的成员，代表在全局范围内声明的变量和函数。
2. `Decl`（声明基类）:
- 表示所有声明的基类，例如变量声明和函数声明。
- 具体的声明通过派生类表示，如 `VarDecl` 和 `FunctionDecl`。
3. `Expr`（表达式基类）:
- 所有表达式节点的基类，比如字面量、二元运算、函数调用等。
- 具体的表达式通过派生类表示，如 `IntegerLiteral`、`BinaryExpr` 和 `CallExpr`。
4. `Stmt`（语句基类）:
- 所有语句的基类，例如表达式语句和复合语句。
- 具体的语句通过派生类表示，如 `ExprStmt` 和 `CompoundStmt`。
5. `Type` 类和 `TypeExpr`:
- 用于表示节点的类型信息，包括基本类型和复合类型。
- `TypeExpr` 用于更复杂的类型表达，如数组和函数类型。

### 类之间的关系
- 从属关系: `TranslationUnit` 作为`ASG`的根节点，包含一系列的 `Decl` 实例，如 `VarDecl` 和 `FunctionDecl`，代表全局声明的变量和函数。这些声明中可能会包含对表达式的引用，例如函数返回类型或者变量初始化表达式，从而关联到 `Expr` 类及其派生类。
- 包含关系: `FunctionDecl` 类会包含 `Stmt` 类的实例，特别是 `CompoundStmt`，以表示函数体。`CompoundStmt` 再包含更多的 `Stmt` 实例，形成一个语句树，这些语句可能是 `ExprStmt`，表示表达式语句，或者是其他复合语句，形成层次结构。
- 引用关系: 表达式（`Expr` 类及其派生类）可能会引用声明（通过 `DeclRefExpr` 类），表示变量的使用或函数的调用。同时，表达式之间也会形成树状结构，如 `BinaryExpr` 的左右子表达式。



## Typing 相关代码介绍

`Typing` 类及其相关函数是设计用来在抽象语法图（`ASG`）中进行类型推导和检查的。通过遍历`ASG`节点并分析其语义，`Typing` 类填充或确认节点的类型信息，以便于后续的代码生成或其他分析阶段使用。以下是详细的介绍：

### Typing 类的主要职责
1. **类型推导**: 对ASG中的表达式和变量进行类型推导，确定它们的具体类型。
2. **类型检查**: 确认代码中的类型使用是否正确，例如赋值操作的左右两侧类型是否兼容。
3. **类型转换**: 根据需要插入隐式或显式的类型转换，保证操作的类型安全。

### Typing 类的核心成员和函数

成员变量
- `Obj::Mgr& mMgr`: 对象管理器的引用，用于在类型推导过程中创建新的类型或表达式对象。
- `Type::Cache mTypeCache`: 类型缓存，用于存储和复用类型实例，避免重复创建相同的类型对象。
  

主要方法
- `operator()(TranslationUnit* tu)`: 对整个翻译单元进行类型推导。这是类型推导过程的入口点。
- `operator()(Expr* obj)`: 对表达式进行类型推导。这个方法会根据表达式的种类调用更具体的处理函数。
- `operator()(Stmt* obj)`: 对语句进行类型处理，确保语句中使用的表达式类型正确。
- `operator()(Decl* obj)`: 对声明进行类型推导和检查，包括变量声明和函数声明。
- `ensure_rvalue(Expr* exp)`: 确保表达式为右值，如果需要，进行左值到右值的转换。
- `promote_integer(Expr* exp, Type::Spec to = Type::Spec::kInt)`: 进行整数提升，将小于 `int` 类型的整数类型提升为 `int` 或更大的整数类型。
- `assignment_cast(Expr* lft, Expr* rht)`: 对赋值操作的右侧进行类型转换，确保与左侧类型兼容。

### 类型推导和转换的代码结构

类型推导
在处理表达式时，`Typing` 类会根据表达式的类型进行分派，调用对应的处理函数。例如，对于整数字面量 (`IntegerLiteral`)，它会确定字面量的类型（是否足够用 `int` 表示，或者需要更大的类型如 `long long`）。
```c++
Expr* Typing::operator()(IntegerLiteral* obj) {
  // 确定字面量类型
  Type::Spec spec;
  if (obj->val <= INT32_MAX) {
    spec = Type::Spec::kInt;
  } else {
    spec = Type::Spec::kLongLong;
  }

  obj->type = mTypeCache(spec, Type::Qual{.const_ = true}, nullptr);
  obj->cate = Expr::Cate::kRValue;
  return obj;
}

```

类型检查与转换

对于赋值操作，Typing 会检查左右两侧的类型是否兼容，并在需要时插入隐式类型转换。
```c++
Expr* Typing::assignment_cast(Expr* lft, Expr* rht) {
  // 检查类型兼容性，并进行必要的类型转换
  if (lft->type->spec != rht->type->spec) {
    auto cst = make<ImplicitCastExpr>();
    cst->kind = cst->kIntegralCast;
    cst->type = lft->type;
    cst->sub = rht;
    rht = cst;
  }
  return rht;
}

```
这种方法使得 `Typing` 类可以灵活地处理各种类型相关的语义规则，包括基本的类型推导、类型兼容性检查和必要的类型转换。通过将这些功能集中在 `Typing` 类中，代码的其余部分可以在不直接处理复杂类型规则的情况下，进行语义分析和代码生成。


## Asg2Json 相关代码介绍

`Asg2Json.cpp` 和 `Asg2Json.hpp` 定义了一个 `Asg2Json` 类，其目的是将抽象语法图（`ASG`）转换为`JSON`格式的表示。这样的转换使得ASG的结构可以以文本形式展示，便于调试、可视化或进一步的处理。

### Asg2Json 类的主要职责
1. 转换逻辑: 提供将`ASG`中不同节点（如声明、表达式、语句等）转换为`JSON`对象的逻辑。
2. 输出格式化: 生成的`JSON`格式化输出，使其易于阅读和理解。
3. 递归处理: 能够递归处理`ASG`中的复杂结构，如函数内部的语句和表达式。

### 核心方法与结构
**`operator()` 重载**

`Asg2Json` 类为`ASG`中的各种节点类型提供了 `operator()` 方法的重载，每个重载负责处理一种特定类型的节点，并将其转换为`JSON`对象。


- 处理`TranslationUnit`:
  - `json::Object operator()(TranslationUnit* tu)`: 处理整个翻译单元，作为转换的入口点。

- 处理表达式 (`Expr`):
  - `json::Object operator()(Expr* obj)`: 处理所有表达式的基类。它会根据具体的表达式类型（通过动态类型识别）调用相应的处理函数。

- 处理语句 (`Stmt`):
  - `json::Object operator()(Stmt* obj)`: 类似于表达式的处理，这个方法根据语句的具体类型调用相应的处理函数。

- 处理声明 (`Decl`):
  - `json::Object operator()(Decl* obj)`: 处理所有声明的基类。根据声明的类型（如变量声明或函数声明），将其转换为JSON。

**类型和表达式的转换**

- 处理基本类型和复合类型:
  - `std::string operator()(const Type* type)`: 将类型信息转换为字符串表示，用于在JSON中表示变量或表达式的类型。
  - `std::string operator()(TypeExpr* texp)`: 处理复合类型表达式，如数组或函数类型。
  具体表达式和语句的转换

每种具体的表达式和语句类型（如 `IntegerLiteral`, `BinaryExpr`, `CompoundStmt` 等）都有对应的处理方法，这些方法生成代表该节点的`JSON`对象，并递归地处理节点的子节点（如果有）。


## ASG（抽象语义图）介绍

相比起AST（抽象语法树），在本实验中使用ASG（抽象语义图）更为恰当和合适（类似于AST，只是其的一种简化or变体，更能将其方便的json的转化和输出）。

### 语法解析树、抽象语法树、抽象语义图的对比
在学习了这么多编译原理的课程知识后，相信同学们已经了解了“语法解析树”和“抽象语法树”的概念，这里我们把它们进行对比一下，使用的例子是一个很短的全局变量声明：`int a[2] = {0, 1}, *b = a + 1;`。
- **语法解析树（Parse Tree）**
语法解析树包含语法解析过程中的所有非终结符号和终结符号，一个递归下降语法分析器的运行过程可以视为是对语法解析树的深度优先遍历。语法解析树通常是非常复杂和庞大的，因此一般并不会真的生成出来，例如上面的例子如果真的生成一个语法解析树，那他可能是这个样子：
![alt text](../images/bison/Parse_Tree.png)
希望这张图能够让你感受到语法解析树的复杂和庞大。而实际上，上图其实已经简化了表达式相关语法规则（虚线表示），后面为我们会看到，因为运算符优先级的存在，每个表达式结点实际上都会产生出一个长长的分支链。

- **抽象语法树（Abstract Syntax Tree）**
抽象语法树通过去掉了那些只起到结构标识作用的结点、压缩树的层级等方式大大简化了语法解析树的结构。上面的例子对应的抽象语法树可能是：
![alt text](../images/bison/ast.png)
很显然AST比语法解析树简单得多，ANTLR、Boost.Spirit等此类的语法解析器框架的输出结果往往都是这种形式。

- **抽象语义图（Abstract Semantic Graph）**
单论名字的用法而言，大家并不是那么严格地区分“ASG”和“AST”，很多人把他的IR数据结构称为AST，尽管这些数据结构的引用关系在事实上是图而并非树。不过，相比于那些语法解析器框架，我们上面定义的C++结构体们与之还是有很大差别的，这主要体现在语义结点的相互引用上：
<img src="../images/bison/asg.png" alt="alt text" style="zoom: 60%;" />
相比于AST中存储的是变量名，我们在`declReference_1`中直接存储指向变量声明的那个语义结点指针，这将会给后面的分析和变换的代码编写带来极大的便利。

### ASG总结
其实能够理解到ASG就是一种可以储存代码中的各个不同结构（比如，表达式，句子，声明）的一堆结构体就可以了。我们使用ASG结构并不是必须的，只是为了在中间进行储存这些文法结构，从而方便地进行之后的json打印，这只是一种代码设计的方案。









